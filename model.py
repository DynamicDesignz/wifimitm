#!/usr/bin/env python3
"""
Model

Automatization of MitM Attack on WiFi Networks
Bachelor's Thesis UIFS FIT VUT
Martin Vondracek
2016
"""
import csv
import logging
import os
import tempfile
import time
import subprocess

__author__ = 'Martin Vondracek'
__email__ = 'xvondr20@stud.fit.vutbr.cz'


def csv_row_station_bssid(row):
    """
    Provide associated bssid of given station.
    :param row: list of strings representing one row of csv file generated by airodump-ng during scanning
    :return: string bssid
    """
    return row[5].strip()


def csv_row_to_station(row):
    """
    Convert csv row to station.
    :param row: list of strings representing one row of csv file generated by airodump-ng during scanning
    :return: WirelessStation object
    """
    mac_address = row[0].strip()
    power = row[3].strip()
    return WirelessStation(mac_address, power)


def csv_row_to_ap(row):
    """
    Convert csv row to AP.
    :param row: list of strings representing one row of csv file generated by airodump-ng during scanning
    :return: WirelessAccessPoint object
    """
    bssid = row[0].strip()
    power = row[8].strip()
    channel = row[3].strip()
    encryption = row[5].strip()
    cipher = row[6].strip()
    authentication = row[7].strip()
    # TODO (xvondr20) WPS detection with Reaver?
    # wps = row[6].strip()
    wps = False
    #
    essid = row[13].strip()
    iv_sum = row[10].strip()
    return WirelessAccessPoint(bssid, power, channel, encryption, cipher, authentication, wps, essid, iv_sum)


def csv_to_result(csv_path):
    """
    Convert csv output file, generated by airodump-ng during scanning, to scan result.
    :param csv_path: path to csv output file
    :return: List containing WirelessAccessPoint objects with associated WirelessClient objects.
    """
    scan_result = list()
    with open(csv_path, newline='') as csvfile:
        reader = csv.reader(csvfile, delimiter=',')
        for row in reader:
            if len(row) < 2 or row[1] == ' First time seen':  # skip section headers and empty lines
                continue
            elif len(row) == 15:  # reading access points section
                ap = csv_row_to_ap(row)
                scan_result.append(ap)
            elif len(row) == 7:  # reading stations section
                station = csv_row_to_station(row)
                associated_bssid = csv_row_station_bssid(row)
                # add station to associated access point, stations section is read after access points section
                for ap in scan_result:
                    if ap.bssid == associated_bssid:
                        ap.add_associated_station(station)
    return scan_result


class WirelessStation(object):
    def __str__(self, *args, **kwargs):  # TODO (xvondr20) just for debugging
        return 'WirelessStation(' + ', '.join([
            self.mac_address,
            self.power
        ]) + ')'

    def __init__(self, mac_address, power):
        self.mac_address = mac_address
        self.power = power

        self.associated_ap = None


class WirelessAccessPoint(object):
    def __str__(self, *args, **kwargs):  # TODO (xvondr20) just for debugging
        s = 'WirelessAccessPoint(' + ', '.join([
            self.essid,
            self.bssid
        ])

        if self.is_cracked():
            s += ', PSK(0x' + self.cracked_psk + ', "' + bytes.fromhex(self.cracked_psk).decode('ascii') + '"), '

        s += ', '.join([
            self.power,
            self.channel,
            self.encryption,
            self.cipher,
            self.authentication,
            str(self.wps),
            self.iv_sum
        ]) + ')'
        return s

    def __init__(self, bssid, power, channel, encryption, cipher, authentication, wps, essid, iv_sum):
        self.bssid = bssid
        self.power = power
        self.channel = channel
        self.encryption = encryption
        self.cipher = cipher
        self.authentication = authentication
        self.wps = wps
        self.essid = essid
        self.iv_sum = iv_sum

        self.associated_stations = list()

    @property
    def dir_path(self):
        """
        Get path to directory which should be dedicated for files related to this network.
        :return: str
        """
        return os.path.join(os.getcwd(), 'networks', self.essid)  # TODO (xvondr20) what is essid is not available?

    def make_dir(self):
        """
        Make directory to store files related to this network, if does not exist already.
        """
        os.makedirs(self.dir_path, exist_ok=True)

    @property
    def cracked_psk_path(self):
        """
        Get path to location where cracked PSK should be located after successful crack.
        Path to PSK is returned even if the file does not exists (have not been successfully cracked yet).
        :return: str
        """
        return os.path.join(self.dir_path, self.encryption + '_PSK.hex')

    def is_cracked(self):
        """
        Decide whether the network have been successfully cracked and therefore a PSK is available.
        :return: bool
        """
        return os.path.isfile(self.cracked_psk_path)

    @property
    def cracked_psk(self):
        """
        Get hexadecimal cracked PSK if available. If the network have not been cracked yet, therefore PSK is not
        available, returns None.
        :return: str|None
        """
        if self.is_cracked():
            with open(self.cracked_psk_path, 'r') as f:
                psk_hex = f.read()
                return psk_hex

    def add_associated_station(self, station):
        station.associated_ap = self
        self.associated_stations.append(station)


class WirelessScanner(object):
    def __init__(self, tmp_dir, interface):
        self.tmp_dir = tmp_dir
        self.interface = interface

        self.process = None
        self.scanning_dir = None
        self.scanning_csv_path = None

    def start(self, write_interval=5):
        self.scanning_dir = tempfile.TemporaryDirectory(prefix='WirelessScanner-', dir=self.tmp_dir)
        cmd = ['airodump-ng',
               '-w', os.path.join(self.scanning_dir.name, 'scan'),
               '--output-format', 'csv',
               '--write-interval', str(write_interval),
               '-a',
               self.interface]
        self.process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        self.scanning_csv_path = os.path.join(self.scanning_dir.name, 'scan-01.csv')
        logging.debug('scan started')

    def stop(self):
        if self.process:
            exitcode = self.process.poll()
            if exitcode is None:
                self.process.terminate()
                time.sleep(1)
                self.process.kill()
                exitcode = self.process.poll()
                logging.debug('scan killed')

            self.process = None
            self.scanning_dir.cleanup()
            self.scanning_dir = None
            self.scanning_csv_path = None
            return exitcode

    def scan_once(self):
        """
        Scans once for wireless APs and clients.
        Scanning is done by airodump-ng for 5 seconds. After scanning, airodump-ng is terminanted.
        :return: List containing WirelessAccessPoint objects with associated WirelessStation objects.
        """
        self.start(write_interval=5)
        time.sleep(5)
        result = csv_to_result(self.scanning_csv_path)
        self.stop()
        return result

    def get_scan_result(self):
        while not self.has_csv():
            logging.debug('WirelessScanner polling result')
            time.sleep(1)
        return csv_to_result(self.scanning_csv_path)

    def has_csv(self):
        return os.path.isfile(self.scanning_csv_path)


class WirelessCapturer(object):
    def __init__(self, tmp_dir, interface):
        self.tmp_dir = tmp_dir
        self.interface = interface

        self.capturing_process = None
        self.capturing_dir = None
        self.capturing_csv_path = None
        self.capturing_cap_path = None

    def start(self, ap):
        self.capturing_dir = tempfile.TemporaryDirectory(prefix='WirelessCapturer-', dir=self.tmp_dir)
        cmd = ['airodump-ng',
               '--bssid', ap.bssid,
               '--channel', ap.channel,
               '-w', os.path.join(self.capturing_dir.name, 'capture'),
               '--output-format', 'csv,pcap',
               '--write-interval', '5',
               '-a',
               self.interface]
        self.capturing_process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        self.capturing_csv_path = os.path.join(self.capturing_dir.name, 'capture-01.csv')
        self.capturing_cap_path = os.path.join(self.capturing_dir.name, 'capture-01.cap')
        logging.debug('capture started')

    def stop(self):
        if self.capturing_process:
            self.capturing_process.terminate()
            time.sleep(1)
            self.capturing_process.kill()
            self.capturing_process = None
            self.capturing_dir.cleanup()
            self.capturing_dir = None
            self.capturing_csv_path = None
            self.capturing_cap_path = None
        logging.debug('capture stopped')

    def get_capture_result(self):
        while not self.has_capture_csv():
            logging.debug('WirelessCapturer polling result')
            time.sleep(1)
        return csv_to_result(self.capturing_csv_path)

    def has_capture_csv(self):
        return os.path.isfile(self.capturing_csv_path)

    def get_iv_sum(self):
        # TODO (xvondr20) Get '#IV' without parsing whole result of objects.
        aps = self.get_capture_result()
        if len(aps):
            return aps[0].iv_sum
        else:
            return 0
